#变量的分类
##按数据类型分类
以下是Java的数据类型，用表格形式呈现：
### 基本数据类型（Primitive Data Types）：

| 类型         |        描述        | 默认值         | 大小（字节） | 范围                                | 
|:------------:|:------------------:|:--------------:|:----------:|:----------------------------------:|
| `byte`         |     有符号整数      |       0        |      1     |          -128 到 127               |
| `short`        |     有符号整数      |       0        |      2    |        -32,768 到 32,767          |
| `int`          |     有符号整数      |       0        |      4    |  -2^31 到 2^31 - 1                |
| `long`         |     有符号整数      |       0L       |      8    |  -2^63 到 2^63 - 1                |
| `float`        |     单精度浮点数    |      0.0f      |      4    | 约为 1.4E-45 到 3.4E38            |
| `double`       |     双精度浮点数    |      0.0       |      8    |约为 4.9E-324 到 1.8E308           |
| `char`         |       单个字符      |   '\u0000'     |      2    | Unicode字符，无符号，0 到 2^16 - 1 |
| `boolean`      |       布尔值        |     false      |     内存4字节   |          true 或 false             |

####整型
* 声明long型变量，必须以"l"或"L"结尾
* 通常，定义整型变量时，使用int型。
* 整型常量的默认类型是：int型
```java
// 声明字节类型变量
byte data = 127;

// 声明整数类型变量
int age = 25;

// 声明长整数类型变量
long population = 7000000000L;  // 注意：long类型的变量末尾需要加上L或l

// 声明短整数类型变量
short temperature = -10;
```
####浮点型
* 浮点型，表示带小数点的数值
* float表示数值的范围比long还大
* 定义float类型变量时，变量要以"f"或"F"结尾
* 通常，定义浮点型变量时，使用double型。
* 浮点型的常量，默认类型为：double
```java
// 声明单精度浮点数类型变量
float height = 1.75f;  // 注意：float类型的变量末尾需要加上f或F
        
// 声明浮点数类型变量
double salary = 50000.50;
```
####字符型
* 定义char型变量，通常使用一对单引号`''`,内部只能写一个字符
* 表示方式：  
  1. 声明一个字符 
  2. 转义字符 
  3. 直接使用 Unicode 值来表示字符型常量
```java
// 声明字符类型变量
char grade = 'A';
char escapeChar = '\n';    // 表示换行符
char unicodeChar = '\u0041';  // 表示Unicode字符 'A'
```
####布尔型
* 只能取两个值之一：`true`/`false`
* 常常在条件判断、循环结构中使用
* 布尔类型在在内存中使用的是4个字节
```java
// 声明布尔类型变量
boolean isStudent = true;
```

### 引用数据类型（Reference Data Types）：

| 类型            |        描述        | 默认值  |
|:--------------:|:------------------:|:-------:|
| `class`        |     类             |  `null` |
| `interface`    |     接口           |  `null` |
| `[]`           |     数组           |  `null` |
| `enum`         |   枚举类型         |  `null` |
| `Annotation`   |     注解           |  `null` |
| `Void`         |     空类型         |  无法表示 |
#### 类（class）
```java
//类的声明
public class MyClass {
    // 类的代码
}
```
#### 接口（interface）
```java
//接口的声明
public interface MyInterface {
    // 接口的代码
}
```
#### 数组（array）
```java
//数组的声明
int[] arr; // 先声明
arr = new int[5]; //再赋值 
        
int[] arr = new int[5];// 一次性声明并赋值

int[] arr = {1, 2, 3, 4, 5}// 直接声明并显示赋值
```
#### 枚举（enum）
```java
//枚举的声明
public enum MyEnum {
    // 枚举的代码
}
```
#### 注解（annotation）
```java
//注解的声明
public @interface MyAnnotation {
    // 注解的代码
}
```
##按声明的位置分类
####成员变量
* 实例变量
```java
public class MyClass {
    // 实例变量，
    int x;  //实例变量随着类的实例化而存在，随着实例的消失而消失实例的消失而消失

    public static void main(String[] args) {
        
        //在类实例化之前，
        //无法访问实例变量
        System.out.println(x);  // 编译错误，无法访问
        
        // 实例化对象
        MyClass obj = new MyClass();
        // 调用实例变量
        System.out.println(obj.x);
        // 输出结果：0
    }
}
```  
* 类变量(static)
```java
public class MyClass {
  // 类变量
  // 类变量属于类，随着类的加载而存在，随着类的消失而消失
  static int count;

  public static void main(String[] args) {
    //类变量随着类的加载而存在，可以通过类直接访问
    System.out.println(MyClass.count);
  }
}
```  
**注:类成员会随着类的加载而被执行，实例成员会随着实例的创建而被执行。**
####局部变量
* 形参
```java
public class Example {
    // 方法定义，包含两个形参
    public static void addNumbers(int a, int b) {
        int sum = a + b;
        System.out.println("Sum of " + a + " and " + b + " is: " + sum);
    }

    public static void main(String[] args) {
        // 方法调用，传递实际参数给形参
        addNumbers(5, 10);
        addNumbers(20, 30);
    }
}
```  
* 方法局部变量
```java
public class Example {
    // 方法定义
    public static void calculateSum(int a, int b) {
        // 方法局部变量
        int sum = a + b;
        System.out.println("Sum of " + a + " and " + b + " is: " + sum);
    }

    public static void main(String[] args) {
        // 方法调用，传递实际参数给形参
        calculateSum(5, 10);
        calculateSum(20, 30);
    }
}
```   
* 代码块局部变量
```java
public class Example {
    public static void main(String[] args) {
        // 代码块局部变量
        int x = 10;

        // 进入代码块
        {
            int y = 20;
            System.out.println("Inside the block: x + y = " + (x + y));
        }

        // 无法访问代码块内的局部变量 y
        // System.out.println("Outside the block: x + y = " + (x + y)); // 编译错误

        // 仍然可以访问代码块外的局部变量 x
        System.out.println("Outside the block: x = " + x);
    }
}

```     
## 定义变量的格式
```java
//数据类型 变量名 = 变量值;
int a = 10; //直接赋值
//或
//数据类型  变量名;
int b; //先定义
//变量名 = 变量值;
b = 10; //后赋值
```
### 变量使用的注意点：
* 变量必须先声明，后使用
* 变量要想使用，必须赋值(如果显式赋值，也必须保证它有初始值)
* 变量都定义在其作用域内。在作用域内，它是有效的。换句话说，出了作用域，就失效了
  * 类级别的作用域
  * 实例级别的作用域
  * 方法级别的作用域
  * 代码块级别的作用域
  * 流程控制级别的作用域
* 同一个作用域内，不可以声明两个同名的变量
## 基本数据类型变量间运算规则
**涉及到的基本数据类型：除了boolean之外的其他7种**
### 自动类型转换(只涉及7种基本数据类型）
结论：当容量小的数据类型的变量与容量大的数据类型的变量做运算时，结果自动提升为容量大的数据类型。

	byte 、char 、short --> int --> long --> float --> double 
* **特别的**：当byte、char、short三种类型的变量做运算时，结果为`int`型
* 说明：此时的容量大小指的是，`表示数的范围的大和小`。比如：float容量要大于long的容量
### 强制类型转换(只涉及7种基本数据类型）：自动类型提升运算的逆运算。

1. 需要使用强转符：`()`
2. 注意点：强制类型转换，可能导致精度损失。
## String与8种基本数据类型间的运算

1. String属于引用数据类型,翻译为：字符串
2.  声明String类型变量时，使用一对双引号`""`
3. String可以和8种基本数据类型变量做运算，且运算只能是连接运算：`+`
4. 运算的结果仍然是String类型
```java
String s = 123;//编译错误
String s1 = "123";
int i = (int)s1;//编译错误
```







