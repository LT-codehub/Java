#复习
##1.1关键字、保留字
以下是Java中的一些关键字，包含描述，但描述内容为空：

| 关键字           | 描述                                                         |
|------------------|--------------------------------------------------------------|
| abstract         | 用于修饰类，表示这个类是一个抽象类，不能被实例化                      |
| assert           | 用于调试，断言。assert关键字修饰表达式的结果为true则正常执行，为false则抛出特定异常 |
| boolean          | 用于修饰变量，表示布尔类型的变量，大小4字节，有true和false两个值，默认值为false   |
| break            | 用于循环结构，表示是`跳出当前循环体或分支结构`                                                     |
| byte             | 用于修饰变量，表示字节型数据， 大小1字节，默认值为0                                                            |
| case             | 用于循环结构，表示switch分支项                                       |
| catch            | 用于异常控制，表示异常的捕获                                        |
| char             | 用于修饰变量，表示字符型的变量，大小2字节，默认值为字符表的第一个字符，    |
| class            | 用于修饰类，表示当先声明的是一个类                                                             |
| const*           | 保留字                                                           |
| continue         | 用于循环结构，表示`跳过本次循环或分支`                                      |
| default          | 用于循环结构，表示switch分支结构的默认执行体                           |
| do               | 用于循环结构，while循环的循环体必定会执行一次                                                             |
| double           | 用于修饰变量，表示双精度浮点型的数据，大小8字节，默认值为0.0,小数的默认类型就是double  |
| else             | 用于分支结构，表示分支结构的其中一个分支                                                             |
| enum             | 用于修饰枚举，表示当前修饰的是一个枚举，枚举的本质是一个特殊的单例类         |
| extends          | 用于修饰类和接口，表示当前类或者接口继承某个或某些类或者接口              |
| final            | 用于修饰变量/类/方法，表示被修饰变量的值不能修改/类不能被继承/方法不能被重写  |
| finally          | 用于异常处理，表示有异常被捕获后，必定会执行finally中的代码               |
| float            | 用于修饰变量，表示单精度浮点型数据，大小为4字节，默认值为0.0F                 |
| for              | 用于循环结构，声明for循环体                            |
| if               | 用于分支结构，声明if分支结构                                           |
| implements       | 用于实现接口，表示当前类实现某个/某些接口，必须重写被实现接口的可重写方法       |
| import           | 用于包管理，表示从外部引入某些类                                     |
| instanceof       | 用于用于测试对象是否为特定类的实例，实例a instanceof 类b，              |
| int              | 用于修饰变量，表示整形数据，大小4字节，默认值为0,整数的默认数据类型就是int   |
| interface        | 用于修饰接口，表示当先声明的是一个接口                                 |
| long             | 用于修饰变量，表示长整型，大小8字节，默认值0L                                                             |
| native           | 用于                                                             |
| new              | 用于实例化类                                                      |
| package          | 用于包管理，声明当前类/接口处于当前项目的那个位置                         |
| private          | 用于类结构访问权限的管理，是对封装性的具体呈现，当前类可访问         |
| protected        | 用于类结构访问权限的管理，是对封装性的具体呈现，同一工程可访问               |
| public           | 用于类结构访问权限的管理，是对封装性的具体呈现，公开的，可以任意访问         |
| return           | 用于结束当前方法                                                             |
| short            | 用于修饰变量，表示短整型，大小2字节，默认值为0，                           |
| static           | 用于声明类的静态结构，表示当前修饰的结构独属于当前类，随着类的加载而被加载，被当前类的所有实例共享
| strictfp         | 用于                                                             |
| super            | 用于子类的构造方法中，必须位于构造方法的第一行，可以通过`super.方法`的形式在在构造方法中调用父类的结构    |
| switch           | 用于声明switch结构                                                 |
| synchronized     | 用于线程安全，自动锁，只有拿到锁的线程才拥有被修饰代码的执行权限             |
| this             | 用于调用当前实例的成员，this表示的就是当前实例，通过`this.xx`的形式可以调用当前实例的成员|
| throw            | 用于声明手动抛出异常                                                |
| throws           | 用于向当前类的调用者抛出异常，就是把异常抛给上一层                        |
| transient        | 用于                                                             |
| try              | 用于声明异常捕获代码                                                   |
| void             | 用于修饰方法，表示当前方法没有返回值                             |
| volatile         | 用于                                                             |
| while            | 用于声明while循环结构                                                |

(*) 关键字 `const` 已经被废弃，不再使用。

##1.2标识符
主要就是命名规范，类名/方法名/变量名/常量名/包名等，命名规则：
1. 只能包含字母、数字、下划线、$符号
2. 不能以数字开头
3. 不能是关键字或保留字
4. 区分大小写
5. **见名知意**
```java
// 包名
com.atguigu.java //全小写

// 类名
HelloWorld //首字母大写

// 方法名
getUserName //首字母小写，后面的每个单词首字母大写

// 变量名
userName //首字母小写，后面的每个单词首字母大写

// 常量名
MAX_VALUE //全部大写，用下划线连接
```
##1.3变量的基本使用（重点）
##1.3.1变量定义
* 遵循命名规范
* 变量定义格式：数据类型 变量名 = 变量值;
* char类型有多种赋值方式：字符/转义字符/Unicode编码
##1.4基本数据类型变量的使用（重点）
变量的使用必须保证其有值
注意变量的作用域
##1.5基本数据类型变量间的运算规则(重点)
###1.5.1自动类型提升
###1.5.2强制类型转换
##1.6 String类的便用、与基本数据类型变量间的运算（重点）
##1.7常识：进制的认识
##1.8运算符（较常用的是重点）
###1.8.1算术运算符
###1.8.2赋值运算符
###1.8.3比较运算符
###1.8.4逻辑运算符
###1.8.5位运算符
###1.8.6条件运算符
#面试

##1.高效的方式计算2*8的值
使用位运算：2<<3 = 8
为什么更高效？因为计算机在硬件层面对位运算进行了优化

##2.&和&&的区别？
忘了
&是位运算，&&是逻辑运算
对于表达式来说：
* &在任意情况下两边的表达式都会执行
* &&在左边为假的情况下(&&运算的结果确定了)，右边的表达式就不会执行
##3.Java中的基本类型有哪些？String是最基本的数据类型吗？
整型4种
浮点型2种
字符型1种
布尔型1种
String不是基本数据类型，是引用数据类型
##4.Java中的基本数据类型包括哪些？
上题相同
##5.Java开发中计算金额时便用什么数据类型？
使用BigDecimal，因为BigDecimal的本质是一个字符串，不会出现精度问题。
为什么不使用浮点数？因为浮点数的小数部分有精度问题，原因在于浮点数的表示精度有限，但是很多时候小数的计算结果表示会超出这个精度，就会被舍去
##6.char型变量中能不能存储一个中文汉字， 为什么？
能
##7.代码分析

##8.int=0;i=i++执行这两句化后变量i的值为
i = 0，因为i++的是对i执行性++之前的值
##9.如何将两个变量的值互换
首先保证变量是数值型
三种方法：
1. 定义中间变量(推荐)
2. 使用异或运算：a=a^b;b=a^b;a=a^b;(效率最高)
3. 使用加减法：a=a+b;b=a-b;a=a-b;但是可能会出现溢出)

##10.boolean占几个字节
4个
```markdown
javac编译时不谈占几个字节。
但是JVM在给boolean类型分配内存空间时，boolean类型的变量占据一个槽位(slot等于4个字节)。
>拓展：在内存中，byte\short\int\boolean\float:占用1个slot
    double\long:占用2个s1ot
```
##11.为什么Java中0.1+0.2结果不是0.3？
Java中因为浮点数采用IEEE 754标准，
IEEE 754标准的本质就是为了解决小数二进制的实际精度不能被完全表示的问题，

具体就是:`小数二进制的实际精度超出了计算机浮点数能够表示的精度`，当精度超出是就会按照一定规则被四舍五入，
所以0.1+0.2的结果会被截断，最后的结果不是0.3，而是0.30000000

##12.break和continue的作用
break在switch和循环中，跳出当前的switch和循环  
continue在循环中，跳过本次循环的剩余代码，继续下一次循环
##13.if分支语句和switch分支语句的异同之处
* if可以进行范围判断，使用范围更广
* if只能执行单个分支

* switch只能进行值判断，适用范围较窄
* switch在进行等值判断时效率更高
* switch可以同时执行多个分支
##14.什么时候用语句 if,什么时候选用语句switch
同上
##15.switchi语句中忘写break会发生什么
会将剩下的分支依次执行
##16.Java支持哪些些类型循环
for
foreach:语法糖，本质是iterator迭代器
while
do while
##17.while和do while循环的区别
while是先判断后执行，do while是先执行一次后判断


