**首先明确一点，Java是**`**值传递**`
# Base
首先我们要明确，讨论值传递和引用传递的主体的`参数`，而参数的主体则是`方法`，所以我们的`讨论主体`是**方法的参数**
## 实参和形参
实参：方法被调用时，`实际被传递`进来的参数 
形参：在`定义方法时`定义语句中使用的参数，目的是调用函数时`接收传入的参数`
```java
public static void main(String[] args) {
    Test("java");
}
public static void Test(String name) {//这里的name就是形参，在运行时只起到接收实参的作用
	System.out.println(name) //这里的name就是实参，是真实的数据"java"，运行时被实际使用
}
```
### 求值策略
求值策略是确定编程语言中`表达式的求值`的一组（通常确定性的）规则。求值策略定义何时和以何种顺序求值给函数的实际参数、什么时候把它们代换入函数、和代换以何种形式发生。
求值策略分为**两大基本类**，**基于如何处理给函数的实际参数**，分位`严格`的和`非严格`的。
严格求值中有几个关键的求值策略是我们比较关心的，那就是**传值调用**（Call by value）、**传引用调用**（Call by reference）以及**传共享对象调用**（Call by sharing）。
#### 传值调用（值传递）

1. 求值并绑定到函数中的变量(通常通过将值复制到一个新的内存区域)，就是说：实际参数先被求值，然后其值通过复制，被传递给被调函数的形式参数
2. 当函数返回时，传递给函数调用的任何内容在调用者的作用域中都是不变的

优点：避免了`野指针`、`强制类型转换造成的内存误修改`，开发者不需要额外的去做内存管理
缺点：由于需要拷贝副本是对于复杂结构类型的参数的传递效率要低于只引用传递
> 这里有个特殊情况，就是对于多态的情况，如果方法参数用的是父类，而传递的值是子类，name在进行值传递的时候，value copy只会对父类的结构进行构造，对于子类自有的特殊模块会丢弃，所以在值传递的情况下，想在方法内使用子类的特性是无法实现的。

#### 传引用调用（引用传递）
引用传递将实际值的`地址`传递到函数中，那么在function中的修改就会对原值产生影响。
优点：传递的效率高效，稳定
缺点：`野指针`、`强制类型转换造成的内存误修改`，这些问题使开发者进行严格的内存管理
#### 传共享对象调用（共享对象传递）
因为传共享对象调用的过程和传值调用的过程是一样的，而且都有一步关键的操作，那就是"复制"，所以，**通常我们认为传共享对象调用是传值调用的特例，也可以说其是两者的融合版本**
```java
1. 程序在编译时分别将指针和引用添加到符号表上，符号表上记录的是变量名及变量所对应地址。
2. 指针变量在符号表上对应的地址值为指针变量的地址值，而引用在符号表上对应的地址值为引用对象的地址值。
3. 符号表生成后就不会再改，因此指针可以改变其指向的对象（指针变量中的值可以改），而引用对象则不能修改。
```
个人认为共享对象传递是融合值传递和引用传递的产物：

1. 共享对象引用的传递效率稳定，效率相对较高
2. 共享对象引用不可空引用，使用空对象会抛异常
3. 共享对象引用有类型限制，类型不对编译都不过了

**值传递和引用传递，两者的最主要区别就是是**`**直接传递**`**的，还是**`**传递的是一个副本**`
# [为什么说Java中只有值传递](https://hollischuang.gitee.io/tobetopjavaer/#/basics/object-oriented/why-pass-by-reference?id=%e4%b8%ba%e4%bb%80%e4%b9%88%e8%af%b4java%e4%b8%ad%e5%8f%aa%e6%9c%89%e5%80%bc%e4%bc%a0%e9%80%92)

1. **如果我们只**`**关注过程**`**，共享对象传递和值传递是相同的，所以说Java是值传递。从内存层面上，Java的参数传递时发生的值的**复制，栈区中对象的引用被复制了一份，这符合值传递的特征
2. **引用传递传递的这个引用是内存地址，但是对象引用传递的是对象的引用，对象的引用!=内存地址**
   1. 我们一般将引用传递中的引用视为指针也就是内存地址：
      1. 指针可以指向任意一个地址（甚至空地址），引用只能指向一个对象（不可空引用）
         1. 指针可以**对地址进行加减操作**，从而修改相邻地址的数据，比如修改一个数组
         2. 指针不能自动解除指向；而引用在指向的对象销毁时，会自动解引用
      2. 指针可以随意修改所指向地址的数据
         1. 引用只能修改所指向对象的**固定成员**，或者通过所指向对象提供的**固定方法**来修改数据
# 参考：
[https://hollischuang.gitee.io/tobetopjavaer/#/basics/object-oriented/java-pass-by](https://hollischuang.gitee.io/tobetopjavaer/#/basics/object-oriented/java-pass-by)
[Java Evaluation Strategies](https://blog.csdn.net/lodaner/article/details/117232018)
[Java的引用到底是什么？和C/C++的指针有什么区别？](https://zhuanlan.zhihu.com/p/493379406)
