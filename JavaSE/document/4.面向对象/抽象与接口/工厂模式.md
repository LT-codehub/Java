## 1. 解决的问题
实现了创建者与调用者的分离，即**将创建对象的具体过程屏蔽隔离起来**，达到提高灵活性的目的。
## 2. 具体模式
* 简单工厂模式：用来生产同一等级结构中的任意产品。（对于增加新的产品，需要修改已有代码）
```java
// 产品接口
interface Product {
    void display();
}

// 具体产品1
class ConcreteProduct1 implements Product {
    @Override
    public void display() {
        System.out.println("Concrete Product 1");
    }
}

// 具体产品2
class ConcreteProduct2 implements Product {
    @Override
    public void display() {
        System.out.println("Concrete Product 2");
    }
}

// 简单工厂类
class SimpleFactory {
    public static Product createProduct(String type) {
        if ("1".equals(type)) {
            return new ConcreteProduct1();
        } else if ("2".equals(type)) {
            return new ConcreteProduct2();
        }
        return null;
    }
}

public class SimpleFactoryExample {
    public static void main(String[] args) {
        Product product1 = SimpleFactory.createProduct("1");
        product1.display();

        Product product2 = SimpleFactory.createProduct("2");
        product2.display();
    }
}

```  
* 工厂方法模式：用来生产同一等级结构中的固定产品。（支持增加任意产品)
```java
// 工厂接口
interface Factory {
    Product createProduct();
}

// 具体工厂1
class ConcreteFactory1 implements Factory {
    @Override
    public Product createProduct() {
        return new ConcreteProduct1();
    }
}

// 具体工厂2
class ConcreteFactory2 implements Factory {
    @Override
    public Product createProduct() {
        return new ConcreteProduct2();
    }
}

public class FactoryMethodExample {
    public static void main(String[] args) {
        Factory factory1 = new ConcreteFactory1();
        Product product1 = factory1.createProduct();
        product1.display();

        Factory factory2 = new ConcreteFactory2();
        Product product2 = factory2.createProduct();
        product2.display();
    }
}

```  
* 抽象工厂模式：用来生产不同产品族的全部产品。（对于增加新的产品，无能为力；支持增加产品族)
```java
// 抽象产品A
interface AbstractProductA {
    void display();
}

// 具体产品A1
class ConcreteProductA1 implements AbstractProductA {
    @Override
    public void display() {
        System.out.println("Concrete Product A1");
    }
}

// 具体产品A2
class ConcreteProductA2 implements AbstractProductA {
    @Override
    public void display() {
        System.out.println("Concrete Product A2");
    }
}

// 抽象产品B
interface AbstractProductB {
    void display();
}

// 具体产品B1
class ConcreteProductB1 implements AbstractProductB {
    @Override
    public void display() {
        System.out.println("Concrete Product B1");
    }
}

// 具体产品B2
class ConcreteProductB2 implements AbstractProductB {
    @Override
    public void display() {
        System.out.println("Concrete Product B2");
    }
}

// 抽象工厂接口
interface AbstractFactory {
    AbstractProductA createProductA();
    AbstractProductB createProductB();
}

// 具体工厂1
class ConcreteFactory1 implements AbstractFactory {
    @Override
    public AbstractProductA createProductA() {
        return new ConcreteProductA1();
    }

    @Override
    public AbstractProductB createProductB() {
        return new ConcreteProductB1();
    }
}

// 具体工厂2
class ConcreteFactory2 implements AbstractFactory {
    @Override
    public AbstractProductA createProductA() {
        return new ConcreteProductA2();
    }

    @Override
    public AbstractProductB createProductB() {
        return new ConcreteProductB2();
    }
}

public class AbstractFactoryExample {
    public static void main(String[] args) {
        AbstractFactory factory1 = new ConcreteFactory1();
        AbstractProductA productA1 = factory1.createProductA();
        AbstractProductB productB1 = factory1.createProductB();
        productA1.display();
        productB1.display();

        AbstractFactory factory2 = new ConcreteFactory2();
        AbstractProductA productA2 = factory2.createProductA();
        AbstractProductB productB2 = factory2.createProductB();
        productA2.display();
        productB2.display();
    }
}

```











