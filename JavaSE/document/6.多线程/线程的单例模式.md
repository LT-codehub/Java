### 懒汉式单线程版
```java
// 懒汉式 1.0 版本
public class Singleton {
    private static Singleton INSTANCE = null;

    private Singleton() {
    }

    public static Singleton getInstance() {
        if (INSTANCE == null) {
            INSTANCE = new Singleton();
        }
        return INSTANCE;
    }
}
这个代码也有一个缺点，在多线程的场景下instance可能会被多次实例化
```
### 懒汉式多线程版
####懒汉式 2.0 版本
```java

public class Singleton {
    private static Singleton INSTANCE = null;

    private Singleton() {
    }

    public synchronized static Singleton getInstance() {
        if (INSTANCE == null) {
            INSTANCE = new Singleton();
        }
        return INSTANCE;
    }
}
缺点：同步代码的粒度太粗了
```

####懒汉式 3.0 版本
```java
// 懒汉式 3.0 版本
public class Singleton {
    private static Singleton INSTANCE = null;

    private Singleton() {
    }

    public static Singleton getInstance() {
        if (INSTANCE == null) {
            synchronized(Singleton.class){
                INSTANCE = new Singleton();
            }
        }
        return INSTANCE;
    }
}
缺点:有可能导致指令重排
```

####懒汉式 4.0 版本(完整)
```java
// 懒汉式DCL版本
public class Singleton {
    
    private static boolean abcdefff = false;
    //volatile防止指令重排
    //在上一个版本中，INSTANCE = new Singleton()这句代码会被分成以下三步执行：
    //1. 为INSTANCE分配内存空间
    //2. 初始化INSTANCE
    //3. 将INSTANCE指向分配的内存地址
    //但是由于JVM具有指令重排的特性，执行顺序有可能变成1>3>2。
    //这时候如果Instance已经不为空，但是初始化并没有完成，
    //其他线程就会访问到初始化未完成的实例，导致报错。
    //使用volatile可以禁止指令重排，保证在多线程环境下也能正常运行。
    private volatile static Singleton INSTANCE = null;


    private Singleton() {
        synchronized (Singleton.class) {
            if (abcdefff == false) {
                abcdefff = true;
            } else {
                throw new RuntimeException("不要试图使用反射破坏异常");
            }
        }
    }

    public static Singleton getInstance() {
        if (INSTANCE == null) {
            synchronized(Singleton.class){
                if (INSTANCE == null) {
                    INSTANCE = new Singleton();
                }
            }
        }
        return INSTANCE;
    }
}

```
####懒汉式内部类版本(最优)
```java

public class LazySingle {
    private LazySingle(){}

    public static LazySingle getInstance(){
        return Inner.INSTANCE;
    }

    private static class Inner{
        static final LazySingle INSTANCE = new LazySingle();
    }

}
//内部类只有在外部类被调用才加载，产生 INSTANCE 实例；又不用加锁。
//此模式具有之前两个模式的优点，同时屏蔽了它们的缺点，是最好的单例模式
```




