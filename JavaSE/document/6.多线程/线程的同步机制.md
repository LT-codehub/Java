# 只要没有共享数据就不用考虑线程安全问题
**线程同步机制问题在在于多个线程之间发生了`拥挤`，导致`共享数据`出现了问题**
## 背景
例子：创建个窗口卖票，总票数为100张.使用实现Runnable接口的方式？

1. 问题：卖票过程中，出现了`重票`、`错票` -->出现了线程的安全问题
2. 问题出现的原因：当某个线程操作车票的过程中，尚未操作完成时，其他线程参与进来，也操作车票。

如何解决：当一个线程a在操作ticket的时候，其他线程不能参与进来。直到线程a操作完ticket时，其他线程才可以开始操作ticket。这种情况即使线程a出现了阻塞，也不能被改变。
## Java解决方案：同步机制
在Java中，我们通过同步机制，来解决线程的安全问题。
### 方式一：同步代码块
```java
 synchronized(同步监视器){
    //需要被同步的代码

 }

常用：
 synchronized(this){
    //需要被同步的代码

 }

 synchronized(当前类对象){
    //需要被同步的代码

 }
```
#### 说明

1. 操作共享数据的代码，即为需要被同步的代码。  -->不能包含代码多了，也不能包含代码少了。
2. 共享数据：多个线程共同操作的变量。比如：ticket就是共享数据。
3. 同步监视器，俗称：锁。任何一个类的对象，都可以充当锁，但是必須保证锁的`唯一性`
4. 要求：多个线程必须要共用同一把锁。

补充：
* 在**实现Runnable接口**创建多线程的方式中，我们可以考虑`使用this`充当同步监视器。
* 在**继承Thread类**创建多线程的方式中，慎用this充当同步监视器，考虑`使用当前类`充当同步监视器。

### 方式二：同步方法
如果操作共享数据的代码完整的声明在一个方法中，我们不妨将此方法声明同步的。
```java
public synchronized int length() {
        return count;
    }
```
#### 总结

1. 同步方法仍然涉及到同步监视器，只是不需要我们显式的声明。
   1. 非静态的同步方法，同步监视器是：this
   2. 静态的同步方法，同步监视器是：当前类本身

### 方式三：Lock锁  --- JDK5.0新增
```java
class A{
    //1. 创建 Lock 的实例，必须确保多个线程共享同一个 Lock 实例
    //实例化ReentrantLock类
	private final ReentrantLock lock = new ReenTrantLock();
	public void m(){
    //手动加锁
	lock.lock();
	try{
	//保证线程安全的代码;
	}
	finally{
    //手动解锁
	lock.unlock();
			}
		}
}

```
## 总结

使用的优先顺序：
Lock ---> 同步代码块（已经进入了方法体，分配了相应资源 ) --->同步方法（在方法体之外)

1. Lock 是显式锁（手动开启和关闭锁，别忘记关闭锁），synchronized 是隐式锁，出了
   作用域、遇到异常等自动解锁
2. Lock 只有代码块锁，synchronized 有代码块锁和方法锁
3. 使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性
   （提供更多的子类），更体现面向对象。
4. （了解）Lock锁可以对读不加锁，对写加锁，synchronized 不可以
5. （了解）Lock锁可以有多种获取锁的方式，可以从sleep的线程中抢到锁，synchronized不可以

### 利弊
* 同步的方式，解决了线程的安全问题。---好处
* 操作同步代码时，只能一个线程参与，其他线程等待。相当于是一个单线程的过程，效率低，所以**在写同步代码是要考虑同步的粒度**


# 面试题

1. Java是如何解决线程安全问题的，有几种方式？并对比几种方式的不同
2. synchronized和Lock方式解决线程安全问题的对比
- 相同：
   - 二者都可以解决线程安全问题
- 不同：
   - synchronized机制在执行完相应的同步代码以后，自动的释放同步监视器
   -  Lock需要手动的启动同步（lock()，同时结束同步也需要手动的实现unlock()）


