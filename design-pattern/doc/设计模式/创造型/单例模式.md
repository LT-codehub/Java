# 单例模式
意图：保证一个类仅有一个实例，并提供一个访问它的全局访问点。

主要解决：一个全局使用的类频繁地创建与销毁。

何时使用：当您想控制实例数目，节省系统资源的时候。

如何解决：判断系统是否已经有这个单例，如果有则返回，如果没有则创建。

关键代码：构造函数是私有的。

##实例
单例模式在Java应用中是很常用的，例如在Spring中就使用了大量该模式。


* 懒汉式
```java
//（静态变量）
public class Singleton {
    private static Singleton instance = new Singleton();
    private Singleton (){}
    public static Singleton getInstance() {
        return instance;
    }
}


//（静态代码块）
public class Singleton {
    private static Singleton instance;
    private Singleton (){}
    
    static {
        instance = new Singleton();
    }
    public static Singleton getInstance() {
        return instance;
    }
}

```

* 饿汉式
```java
//线程不安全
public class Singleton {
    private static Singleton instance;
    private Singleton (){}
    public static Singleton getInstance() {
        if (instance == null){
            instance =  new Singleton();
        }
        return instance;
    }
}

//线程安全（同步方法）
public class Singleton {
    private static Singleton instance;

    private Singleton() {
    }

    public static synchronized Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}

//线程安全（同步代码块）
public class Singleton {
    private static Singleton instance;
    private Singleton (){}
    public static Singleton getInstance() {
        if (instance == null){
            synchronized(Singleton.class){
                instance =  new Singleton();
            }
        }
        return instance;
    }
}
```
* 双重校验锁
```java
public class Singleton {
    //防止指令重拍
    private static volatile Singleton instance;
    private Singleton (){}
    public static Singleton getInstance() {
        if (instance == null){
            synchronized(Singleton.class){
                if (instance == null){
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

* 静态内部类
```java
class Singleton {
    private static volatile Singleton instance;
    //构造器私有化
    private Singleton()
    //写一个静态内部类，该类中有一个静态属性Singleton
    private static class SingletonInstance{
    private static final Singleton INSTANCE new Singleton():
                //提供一个静态的公有方法，直接返回SingletonInstance.NSTANCE
    public static synchronized Singleton getInstance(){
            return SingletonInstance.INSTANCE}
    }
```
* 枚举
